<!DOCTYPE html>
<html>
<head>
    <meta>
    <title>Asteroides</title>
    <style></style>
</head>
<body>
    <canvas id="gameCanvas" width="700" height="500"></canvas>
    <script>
        
        const FPS = 30; //Frames por segundo.
        const SHIP_SIZE = 30;  // Ship height in pixels.
        const SHIP_AVANCE = 5;  //Aceleracion de la nave en px por segundo.
        const TURN_SPEED = 360; // Velocidad de giro en grados por segundo.
        const FRICCION = 0.7;   //Coeficiente de friccion del espacio (0 = no hay friccion, 1 = mucha friccion).

        /** @type {HTMLCanvasElement} */
        var canv = document.getElementById("gameCanvas"); //Referencia al objeto con ID "GameCanvas"
        var contx = canv.getContext("2d"); //Objeto usado para dibujar en el canvas.

        /* Manejadores de eventos. */
        document.addEventListener("keydown",keyDown);
        document.addEventListener("keyup",keyUp);

        /* Defino la nave como un objeto JSON. */
        var ship = {
            x: canv.width /2,
            y: canv.height /2,
            ratio: SHIP_SIZE / 2,
            angle: (90 / 180 * Math.PI), //Como las funciones matematicas funcionan en radianes tenemos que dividir en 180 y multiplicar por PI
            rota: 0,
            avanzando: false,
            avance: {   //Nos permite que se continue avanzando en dicha direccion cuando soltemos la letra.
                x:0,
                y:0
            }
        }

        /* Seteamos el loop. */
        setInterval(update, 1000 / FPS); //Actualizo cada un tercio de segundo.

        function keyDown(/** @type {KeyboardEvent} */ evt){
            switch(evt.keyCode){

                case 37:  // Comienza rotacion izquierda
                    ship.rota = TURN_SPEED / 180 * Math.PI / FPS;
                    break;

                case 38:  // Empieza a moverse adelante
                    ship.avanzando = true;
                    break;

                case 39:  // Comienza rotacion derecha
                    ship.rota = - TURN_SPEED / 180 * Math.PI / FPS;
                    break;
            }

        }

        function keyUp(/** @type {KeyboardEvent} */ evt){
            switch(evt.keyCode){

                case 37:  // Termina rotacion izquierda
                    ship.rota = 0
                    break;

                case 38:  //  Termina de moverse adelante
                    ship.avanzando = false;
                    break;

                case 39:  // Termina rotacion derecha
                    ship.rota = 0;
                    break;
            }
        }

        function update(){
            /* Dibujamos el espacio */

            contx.fillStyle = "black"; //Seteo color usado para llenar el dibujo
            contx.fillRect(0,0,canv.width,canv.height); // Dimensones del rectangulo.

            /* Avanzamos la nave */
            if(ship.avanzando){ //Mientras mantengamos la tecla de avanzar, la nave se acelera cada vez mas.
                ship.avance.x += SHIP_AVANCE * Math.cos(ship.angle) / FPS;  //Componente avance en x.
                ship.avance.y -= SHIP_AVANCE * Math.sin(ship.angle) / FPS;   //Componente avance en y.

                /* Dibujamos efectos mientras estamos acelerando */
                contx.fillStyle = "red";    //Dentro del fueguito
                contx.strokeStyle = "yellow";    //Color borde del fueguito.
                contx.lineWidth = SHIP_SIZE / 10;   //Ancho de la linea del fueguito.
                contx.beginPath();  //Resetea o comienza la linea que quiero trazar.
                
                /* Parte trasera izquierda. */
                contx.moveTo(  
                    ship.x - ship.ratio * (2 / 3 * Math.cos(ship.angle) + 0.5 * Math.sin(ship.angle)),  //Lo hacemos mas finito al fueguito
                    ship.y + ship.ratio * (2 / 3 * Math.sin(ship.angle) - 0.5 * Math.cos(ship.angle))
                );
                
                /*  Parte trasera central detras de la nave. */
                contx.lineTo(  
                    ship.x - ship.ratio * 4 / 3 * Math.cos(ship.angle),
                    ship.y + ship.ratio * 4 / 3 * Math.sin(ship.angle)
                );

                /* Parte trasera derecha de la nave. */
                contx.lineTo(  // 	Agrega una nueva linea hacia el punto desde el ultimo punto especificado.
                    ship.x - ship.ratio * (2 / 3 * Math.cos(ship.angle) - 0.5 * Math.sin(ship.angle)),  //Lo hacemos mas finito al fueguito
                    ship.y + ship.ratio * (2 / 3 * Math.sin(ship.angle) + 0.5 * Math.cos(ship.angle))
                );
                contx.closePath();    //Cerramos el patron.
                contx.fill();
                contx.stroke(); //Dibuja el camino elegido.

            }else{
                ship.avance.x -= FRICCION * ship.avance.x / FPS;    // Si no se esta avanzando se va frenando.
                ship.avance.y -= FRICCION * ship.avance.y / FPS;
            }

            /* Dibujamos la nave triangular */
            contx.strokeStyle = "white";    //Defino el color del borde de la nave
            contx.lineWidth = SHIP_SIZE / 20;   //Ancho de la linea.
            contx.beginPath();  //Resetea o comienza la linea que quiero trazar.
            
            /* Parte delantera de la nave. */
            contx.moveTo(  //Mueve la linea hacia el punto que especificamos.
                ship.x + 4 / 3  * ship.ratio * Math.cos(ship.angle), 
                ship.y - 4 / 3  * ship.ratio * Math.sin(ship.angle)
            );
            
            /*  Parte trasera izquierda de la nave. */
            contx.lineTo(  // 	Agrega una nueva linea hacia el punto desde el ultimo punto especificado.
                ship.x - ship.ratio * (2 / 3 * Math.cos(ship.angle) + Math.sin(ship.angle)),
                ship.y + ship.ratio * (2 / 3 * Math.sin(ship.angle) - Math.cos(ship.angle))
            );

            /* Parte trasera derecha de la nave. */
            contx.lineTo(  // 	Agrega una nueva linea hacia el punto desde el ultimo punto especificado.
                ship.x - ship.ratio * (2 / 3 * Math.cos(ship.angle) - Math.sin(ship.angle)),
                ship.y + ship.ratio * (2 / 3 * Math.sin(ship.angle) + Math.cos(ship.angle))
            );
            contx.closePath();    //Cerramos el triangulo.
            contx.stroke(); //Dibuja el camino elegido.

            /* Rotamos la nave */
            ship.angle += ship.rota;

            /* Movemos la nave */   
            ship.x += ship.avance.x;    //A pesar que soltemos la tecla, quedara moviendose en esa direccion.
            ship.y += ship.avance.y;

            /* Manejar los margenes */
            
            if(ship.x < 0 - ship.ratio){    //Si nos salimos por la izquierda del margen horizontal.
                ship.x = canv.width + ship.ratio;   //Lo mandamos a la derceha.
            }else if (ship.x > canv.width + ship.ratio){    //Si nos salimos por la derecha del margen horizontal.
                ship.x = 0 - ship.ratio //Lo mandamos por la izquierda.
            }


            if(ship.y < 0 - ship.ratio){    //Si nos salimos por arriba del margen vertical. Esta invertido!
                ship.y = canv.height + ship.ratio;  //Lo mandamos por abajo.
            }else if (ship.y > canv.height + ship.ratio){   //Si nos salimos por abajo del margen vertical.
                ship.y = 0 - ship.ratio //Lo mandamos por arriba.
            }
            /*  Punto del centro */
           contx.fillStyle = "red"; //Seteo color
           //contx.fillRect(ship.x -1, ship.y -1, 2, 2) //Dibujo el patron.
        }
    </script>
</body>
</html>